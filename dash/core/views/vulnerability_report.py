import logging
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from dash.core.models import AssetVulnerability
from dash.core.serializer import AssetVulnerabilityMS
from dash.core.repository.repository import Repository
from dash.core.helpers.utils import decode_file_csv
from rest_framework.filters import SearchFilter, OrderingFilter


#Bloco de configuração dos logs
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
fh = logging.FileHandler('logs/dash-application.log')
fh.setFormatter(formatter)
logger.addHandler(fh)


class ReportViewSet(viewsets.ModelViewSet):
    '''Endpoint para exibir relatório de vunerabilidades, 
       importar dados de csv, gerar nova tabela e atualizar registro '''
    
    queryset = AssetVulnerability.objects.all()
    logger.info('GET API vulnerability_report')
    serializer_class = AssetVulnerabilityMS
    filter_backends = (SearchFilter, OrderingFilter)
    search_fields = [
                    'id', 
                    'hostname', 
                    'ip_addres', 
                    'title', 'severity', 
                    'cvss', 
                    'publication_date', 
                    'status',
                ] #Campos disponíveis para filtro na page view

    def __init__(self, *args, **kwargs):
        ''' Cria tabela principal, caso nao exista '''
        self.repo = Repository()
        self.repo.create_table_if_not_exist()

    def get_serializer_class(self):
        actions = [
            'post',
        ]

        if self.action in actions:
            return AssetVulnerabilityMS
        return self.serializer_class

    @action(detail=False, methods=['post'], url_path='new_data')
    def generate_new_data(self, request):
        ''' Endpoint para gerar novos dados na tabela asset_vulnerability 
            importados de arquivo csv
        '''
        logger.info('Iniciando carga de arquivo csv para gerar nova tabela | Função generate_new_data da view vulnerability_report')
        _file = request.data.get('file', None)
        try:
            data = decode_file_csv(_file)
            logger.debug('Excluindo registro da tabela asset_vulnerability para receber novos dados')
            self.repo.clean_database(table='asset_vulnerability') #Limpa todos os dados da tabela e reseta a key
            
            colums = ['hostname', 'ip_addres', 'title', 'severity', 'cvss', 'publication_date']
            for line in data:
                logger.debug(f'Inserindo novos registros para a tabela | Valores: {line}')
                self.repo.insert_data(table='asset_vulnerability', columns=colums, values=line) #Insere novos registros na tabela asset_vulnerability 

        except Exception as err:
            logger.error(f'Falha ao gerar nova tabela | Erro: {err}')
            return Response(data={'message': 'Falha ao gerar nova tabela'}, status=status.HTTP_400_BAD_REQUEST)    

        logger.info('Nova tabela gerada com sucesso')
        return Response(data={'message': 'Nova tabela gerada com sucesso'}, status=status.HTTP_200_OK)


    @action(detail=False, methods=['post'], url_path='update_status/(?P<pk>.*)')
    def update_status(self, request, pk=None):
        ''' Endpoint para atualizar somente o status de demanda (corrigida ou não corrigida)'''
        
        status_data = request.data['status']
        logger.info(f'Iniciando atualização de status para o registro {pk} | Status -> {status_data}')

        try:
            #chama repository para atualizar registro da tabela asset_vulnerability
            logger.debug('Entrando na tabela asset_vulnerability e inserindo os dados.')
            self.repo.update_record(table='asset_vulnerability', column='status', value=status_data, pk=pk)
        except Exception as err:
            logger.error(f'Erro ao fazer atualização do registro {pk} | Erro: {err}')
            return Response(data={'message': 'Falha na atualização'}, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f'Registro: {pk} atualizado com o valor: {status_data} na base de dados!!')
        return Response(data={'message': 'Registro atualizado'}, status=status.HTTP_200_OK)

